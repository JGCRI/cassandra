"""Miscellaneous utilities for the GCAM driver."""

import os
import os.path
import re
import subprocess
import tempfile
import random

## utility functions used in other gcam python code

## Place holder for the general params structure.  The constructor for
## that structure knows it's supposed to add itself here.  (This is
## kind of ugly.  Maybe we should think up a better way to do it.)
## This variable should be considered private to this module
genparams = None
    

## Often we will have to parse values from a config file that are
## meant to indicate a boolean value.  We list here the strings that
## are considered false; everything else is considered true.
def parseTFstring(val):
    """Parse synonyms for "True" and "False" retrieved from the config file."""
    falsevals = ["False", "false", "FALSE", "F", "f", "No", "NO", "N", 
                 "no", "0"]
    return val.lstrip().rstrip() not in falsevals


## Regular expression for detecting a scenario name (private, used in scenariofix)
scen_pattern = re.compile(r'^"[^"]*"') # Beginning of line, followed by a ", followed
                                       # by any number of non-" chars, followed by a "

def scenariofix(line, newstr="scenario", pat=scen_pattern):
    """Remove commas and excess junk from scenario names.
    
    CSV files returned from the model interface frequently have a
    scenario name as the first field.  The scenario name invariably
    has a comma in it, which really messes up splitting on commas.  We
    almost never use the scenario name for anything, so it's best to
    transform it to something benign.

    arguments:
        line   - Line of text read from a GCAM csv output file. 

      newstr   - (arbitrary) string to substitute in place of the
                 scenario field.

         pat   - Regular expression object for detecting a scenario
                 field.  The default value works for the outputs 
                 typically generated by GCAM, so there should be no
                 need to change it; however, if someone produces a 
                 scenario with a sufficiently weird name, a custom
                 pattern can be supplied through this argument.

    """
    return pat.sub(newstr, line)

def gcam_query(queryfiles, dbxmlfiles, outfiles):
    """Run the indicated queries against a dbxml database

    arguments:
      queryfiles  - List of xml files containing the batch queries to run.  If
                    there is only one, you can just pass the filename.
 
      dbxmlfiles  - List of dbxml file or files to query.  If there is
                    only one, you can just pass the filename.  If
                    there is a list of query files and only a single
                    dbxml, the queries will all be run against the
                    same dbxml.

      outfiles    - List of output files.  should be the same length as
                    the query list.

    """
    if hasattr(queryfiles,'__iter__'):
        qlist = queryfiles
    else:
        qlist = [queryfiles]

    if hasattr(dbxmlfiles, '__iter__'):
        dbxmllist = dbxmlfiles
        if len(dbxmllist) == 1:
            dbxmllist = dbxmllist*len(qlist)
    else:
        dbxmllist = [dbxmlfiles]*len(qlist)

    if hasattr(outfiles, '__iter__'):
        outlist = outfiles
    else:
        outlist = [outfiles]

    ## check for agreement in lengths of the above lists
    if len(dbxmllist) != len(qlist) or len(outlist) != len(qlist):
        raise RuntimeError("Mismatch in input lengths for gcam_query.") 

    ModelInterface = genparams["ModelInterface"]
    DBXMLlib       = genparams["DBXMLlib"]
        
    ### start up the virtual frame buffer.  The Model Interface needs
    ### this even though it won't be displaying anything.
    
    ## We need to select a random display number to avoid collisions
    ## if we're running several driver instances concurrently.
    ## Display numbers up to 1024 seem to be safe.
    random.jumpahead(os.getpid()) # make sure that different instances have different rng states.
    disp = random.randint(1,1024)
    print 'X display is: %d' % disp
    xvfb = subprocess.Popen(['Xvfb', ':%d'%disp, '-pn', '-audit', '4', '-screen', '0', '800x600x16'])
    try:
        ldlibpath = os.getenv('LD_LIBRARY_PATH')
        if ldlibpath is None:
            ldlibpath = "LD_LIBRARY_PATH=%s"%DBXMLlib
        else:
            ldlibpath = "LD_LIBRARY_PATH=%s:%s" % (ldlibpath,DBXMLlib) 

        for (query, dbxml, output) in zip(qlist,dbxmllist,outlist):
            print query, output
            ## make a temporary file
            tempquery = None
            try:
                tempquery = rewrite_query(query, dbxml, output)
                execlist = ['/bin/env', 'DISPLAY=:%d.0'%disp, ldlibpath, 'java', '-jar',
                            ModelInterface, '-b', tempquery]

                subprocess.call(execlist)

            finally:
                if tempquery:
                    os.unlink(tempquery)
    finally:
        xvfb.kill()

    ## output from these queries goes into csv files.  The names of
    ## these files are in the query file, so it's up to the caller to
    ## know or figure out where its data will be.
    return outlist              # probably redundant, since the list of output files was an argument.


### Some regular expressions used in query_file_rewrite (private):
xmldbloc   = re.compile(r'<xmldbLocation>.*</xmldbLocation>')
outfileloc = re.compile(r'<outFile>.*</outFile>')

def rewrite_query(query, dbxml, outfile):
    """Rewrite dbxml query file to include the names of the dbxml file and output file.

    The names of the input dbxml and output csv files are encoded in
    the query file.  Since we want to be able to set them, we need to
    treat the query file as a template and create a temporary with the
    real file names.  This function creates the temporary and returns
    its name.

    """
    (fd, tempqueryname) = tempfile.mkstemp(suffix='.xml') 

    ## copy the input query file line by line into the temp
    ## file; however, edit the xmldb and output locations to
    ## match the arguments.
    origquery = open(query,"r")
    tempquery = os.fdopen(fd,"w")

    dbxmlstr = '<xmldbLocation>' + dbxml + '</xmldbLocation>'
    outfilestr = '<outFile>' + outfile + '</outFile>'

    for line in origquery:
        line = xmldbloc.sub(dbxmlstr, line)
        line = outfileloc.sub(outfilestr, line)
        tempquery.write(line)

    tempquery.close()
    return tempqueryname

        
## regex for removing trailing commas
## TODO:  Do we need to remove multiple trailing commas?
trlcomma = re.compile(r',\s*$')
def rm_trailing_comma(line):
    """Remove trailing comma, if any, from a string."""
    return trlcomma.sub('',line)

## remove trailing newline
## TODO:  why don't we use a regular expression for this?
def chomp(string):
    """Remove trailing newlines, if any, from a string."""
    ## search for last non-newline
    i = -1
    while string[i] == '\n':
        i -= 1
    i += 1                      # forward to the first newline
    if i<0:
        return string[:i]
    else:
        return string

def allexist(files):
    """Test a list of files to determine whether all exist."""
    allfiles = True
    for file in files:
        if not os.path.exists(file):
            allfiles = False
            break
    return allfiles
